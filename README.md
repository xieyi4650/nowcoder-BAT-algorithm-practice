# nowcoder-BAT-algorithm-practice
牛客网买的程序员笔试面试高频题讲解，提升一下自己的C++

# 目录
第一章为免费试听，从第二章开始，第一章是大数据，没有题
## 2_sort
### 冒泡排序
[冒泡排序-C++](2_sort/2_2bubble_sort.cpp)

[冒泡排序-Python](2_sort/2_2bubble_sort.py)

### 选择排序
[选择排序-C++](2_sort/2_3selection_sort.cpp)

[选择排序-Python](2_sort/2_3selection_sort.py)

### 插入排序
[插入排序-C++](2_sort/2_4insert_sort.cpp)

[插入排序-Python](2_sort/2_4insert_sort.py)

### 归并排序
[归并排序-C++](2_sort/2_5merge_sort.cpp)

[归并排序-Python](2_sort/2_5merge_sort.py)

### 快速排序
[快速排序-C++](2_sort/2_6quick_sort.cpp)

[快速排序-Python](2_sort/2_6quick_sort.py)

### 堆排序
[堆排序-递归](2_sort/2_7heap_sort_recursion.cpp)

[堆排序-非递归](2_sort/2_7heap_sort.cpp)

### 计数排序
[计数排序-vector](2_sort/2_10counting_sort_vector.cpp)

[计数排序-array](2_sort/2_10counting_sort.cpp)

[计数排序-Python](2_sort/2_10counting_sort.py)

### 基数排序
[基数排序-queue](2_sort/2_11radix_sort_queue.cpp)

[基数排序-vector](2_sort/2_11radix_sort_vec.cpp)

[基数排序-Python](2_sort/2_11radix_sort.py)

### 小范围排序
已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

给定一个int数组A，同时给定A的大小n和题意中的k，请返回排序后的数组。

测试样例：
[2,1,4,3,6,5,8,7,10,9],10,2
返回：[1,2,3,4,5,6,7,8,9,10]

[小范围排序](2_sort/2_13scale_sort.cpp)
### 重复值判断
请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。

给定一个int数组A及它的大小n，请返回它是否有重复值。

测试样例：
[1,2,3,4,5,5,6],7
返回：true

[重复值判断](2_sort/2_14check_duplicate.cpp)
### 有序数组合
有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。

给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。

[有序数组合](2_sort/2_15mergeAB.cpp)
### 三色排序
有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。

给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。

测试样例：
[0,1,1,0,2,2],6
返回：[0,0,1,1,2,2]

[三色排序](2_sort/2_17sort_three_color.cpp)
### 有序矩阵查找
现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。

给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。

测试样例：
[[1,2,3],[4,5,6],[7,8,9]],3,3,10
返回：false

[有序矩阵查找](2_sort/2_18find_X.cpp)
### 最短子数组
对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。

给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。

测试样例：
[1,4,6,5,9,10],6
返回：2

[最短子数组](2_sort/2_19shortest_subsequence.cpp)
### 相邻两数最大差值
有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。

给定一个int数组A和A的大小n，请返回最大的差值。保证数组元素多于1个。

测试样例：
[1,2,5,4,6],5
返回：2

[相邻两数最大差值](2_sort/2_20gap.cpp)

## 3_string
### 拓扑结构相同子树
对于两棵彼此独立的二叉树A和B，请编写一个高效算法，检查A中是否存在一棵子树与B树的拓扑结构完全相同。

给定两棵二叉树的头结点A和B，请返回一个bool值，代表A中是否存在一棵同构于B的子树。

[拓扑结构相同子树](3_string/3_2chk_identical_tree.cpp)
### 词语变形
对于两个字符串A和B，如果A和B中出现的字符种类相同且每种字符出现的次数相同，则A和B互为变形词，请设计一个高效算法，检查两给定串是否互为变形词。

给定两个字符串A和B及他们的长度，请返回一个bool值，代表他们是否互为变形词。

测试样例：
"abc",3,"bca",3
返回：true

[词语变形](3_string/3_3chk_transform.cpp)
### 两串旋转
如果对于一个字符串A，将A的前面任意一部分挪到后边去形成的字符串称为A的旋转词。比如A="12345",A的旋转词有"12345","23451","34512","45123"和"51234"。对于两个字符串A和B，请判断A和B是否互为旋转词。

给定两个字符串A和B及他们的长度lena，lenb，请返回一个bool值，代表他们是否互为旋转词。

测试样例：
"cdab",4,"abcd",4
返回：true

[两串旋转C++](3_string/3_5rotation_str.cpp)

[两串旋转python](3_string/3_5rotation_str.py)
### 句子的逆序
对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。

给定一个原字符串A和他的长度，请返回逆序后的字符串。

测试样例：
"dog loves pig",13
返回："pig loves dog"

[句子的逆序](3_string/3_6reverse_sentence.cpp)
### 字符串移位
对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后。

给定一个字符串A和它的长度，同时给定len，请返回平移后的字符串。

测试样例：
"ABCDE",5,3
返回："DEABC"

[字符串移位](3_string/3_7string_ranslation.cpp)
### 拼接最小字典序
对于一个给定的字符串数组，请找到一种拼接顺序，使所有小字符串拼接成的大字符串是所有可能的拼接中字典序最小的。

给定一个字符串数组strs，同时给定它的大小，请返回拼接成的串。

测试样例：
["abc","de"],2
"abcde"

[拼接最小字典序](3_string/3_8find_smallest.cpp)
### 空格替换
请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。

给定一个string iniString 为原始的串，以及串的长度 int len, 返回替换后的string。

测试样例：
"Mr John Smith”,13
返回："Mr%20John%20Smith"
”Hello  World”,12
返回：”Hello%20%20World”

[空格替换](3_string/3_10replace_sapce.cpp)
### 合法括号序列
对于一个字符串，请设计一个算法，判断其是否为一个合法的括号串。

给定一个字符串A和它的长度n，请返回一个bool值代表它是否为一个合法的括号串。

测试样例：
"(()())",6
返回：true
测试样例：
"()a()()",7
返回：false
测试样例：
"()(()()",7
返回：false

[合法括号序列](3_string/3_11chk_parenthesis.cpp)
### 最长无重复字符子串
对于一个字符串,请设计一个高效算法，找到字符串的最长无重复字符的子串长度。

给定一个字符串A及它的长度n，请返回它的最长无重复字符子串长度。保证A中字符全部为小写英文字符，且长度小于等于500。

测试样例：
"aabcb",5
返回：3

[合法括号序列](3_string/3_12longest_substring.cpp)

## 4_queue_stack
### 可查询最值的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。

[可查询最值的栈](4_queue_stack/4_2min_stack.cpp)
### 双栈队列
编写一个类,只能用两个栈结构实现队列,支持队列的基本操作(push，pop)。

给定一个操作序列ope及它的长度n，其中元素为正数代表push操作，为0代表pop操作，保证操作序列合法且一定含pop操作，请返回pop的结果序列。

测试样例：
[1,2,3,0,4,0],6
返回：[1,2]

[双栈队列](4_queue_stack/4_4two_stack2queue.cpp)
### 栈的反转
实现一个栈的逆序，但是只能用递归函数和这个栈本身的pop操作来实现，而不能自己申请另外的数据结构。

给定一个整数数组A即为给定的栈，同时给定它的大小n，请返回逆序后的栈。

测试样例：
[4,3,2,1],4
返回：[1,2,3,4]

[双栈队列](4_queue_stack/4_5reverse_stack.cpp)
### 双栈排序
请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。

给定一个int[] numbers(C++中为vector&ltint>)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。

测试样例：
[1,2,3,4,5]
返回：[5,4,3,2,1]

[双栈排序](4_queue_stack/4_6two_stacks_sort.cpp)
### 滑动窗口
有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边,窗口每次向右边滑一个位置。 返回一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。 以数组为[4,3,5,4,3,3,6,7]，w=3为例。因为第一个窗口[4,3,5]的最大值为5，第二个窗口[3,5,4]的最大值为5，第三个窗口[5,4,3]的最大值为5。第四个窗口[4,3,3]的最大值为4。第五个窗口[3,3,6]的最大值为6。第六个窗口[3,6,7]的最大值为7。所以最终返回[5,5,5,4,6,7]。

给定整形数组arr及它的大小n，同时给定w，请返回res数组。保证w小于等于n，同时保证数组大小小于等于500。

测试样例：
[4,3,5,4,3,3,6,7],8,3
返回：[5,5,5,4,6,7]

[滑动窗口](4_queue_stack/4_8slide_window.cpp)
### 数组变树
对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree，MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。

给定一个无重复元素的数组A和它的大小n，请返回一个数组，其中每个元素为原数组中对应位置元素在树中的父亲节点的编号，若为根则值为-1。

测试样例：
[3,1,4,2],4
返回：[2,0,-1,2]

[数组变树](4_queue_stack/4_9max_tree.cpp)

## 5_list
### 环形链表插值
有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。

给定链表的信息，及元素的值A及对应的nxt指向的元素编号同时给定val，请构造出这个环形链表，并插入该值。

测试样例：
[1,3,4,5,7],[1,2,3,4,0],2
返回：{1,2,3,4,5,7}

[环形链表插值](5_list/5_2insert_value.cpp)
### 链表的分化
对于一个链表，我们需要用一个特定阈值完成对它的分化，使得小于等于这个值的结点移到前面，大于该值的结点在后面，同时保证两类结点内部的位置关系不变。

给定一个链表的头结点head，同时给定阈值val，请返回一个链表，使小于等于它的结点在前，大于等于它的在后，保证结点值不重复。

测试样例：
{1,4,2,5},3
{1,2,4,5}

[链表的分化](5_list/5_5list_divid.cpp)
### 打印两个链表的公共值
现有两个升序链表，且链表中均无重复元素。请设计一个高效的算法，打印两个链表的公共值部分。

给定两个链表的头指针headA和headB，请返回一个vector，元素为两个链表的公共部分。请保证返回数组的升序。两个链表的元素个数均小于等于500。保证一定有公共值

测试样例：
{1,2,3,4,5,6,7},{2,4,6,8,10}
返回：[2.4.6]

[打印两个链表的公共值](5_list/5_6find_common_parts.cpp)
### 链表的k逆序
有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1->2->3->4->5->6->7->8->null，K=3这个例子。调整后为，3->2->1->6->5->4->7->8->null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。

给定一个单链表的头指针head,同时给定K值，返回逆序后的链表的头指针。

[链表的k逆序](5_list/5_7k_inverse.cpp)
### 链表指定值清除
现在有一个单链表。链表中每个节点保存一个整数，再给定一个值val，把所有等于val的节点删掉。

给定一个单链表的头结点head，同时给定一个值val，请返回清除后的链表的头结点，保证链表中有不等于该值的其它值。请保证其他元素的相对顺序。

测试样例：
{1,2,3,4,3,2,1},2
{1,3,4,3,1}

[链表指定值清除](5_list/5_8clear_value.cpp)
### 链表的回文结构
请编写一个函数，检查链表是否为回文。

给定一个链表ListNode* pHead，请返回一个bool，代表链表是否为回文。

测试样例：
{1,2,3,2,1}
返回：true
{1,2,3,2,3}
返回：false

[链表的回文结构](5_list/5_9is_palindrome.cpp)
### 复杂链表的复制
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）。

[复杂链表的复制](5_list/5_10random_list_clone.cpp)
### 链表判环
如何判断一个单链表是否有环？有环的话返回进入环的第一个节点的值，无环的话返回-1。如果链表的长度为N，请做到时间复杂度O(N)，额外空间复杂度O(1)。

给定一个单链表的头结点head（注意另一个参数adjust为加密后的数据调整参数，方便数据设置，与本题求解无关)，请返回所求值。

[链表判环](5_list/5_11chkLoop.cpp)

## 6_binary_search
### 局部最小值位置
`定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N>1)时，如果arr[0]<arr[1]，那么arr[0]是局部最小；如果arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；如果0<i<N-1，既有arr[i]<arr[i-1]又有arr[i]<arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。

[局部最小值位置](6_binary_search/get_less_index.cpp)`

### 元素最左出现
对于一个有序数组arr，再给定一个整数num，请在arr中找到num这个数出现的最左边的位置。

给定一个数组arr及它的大小n，同时给定num。请返回所求位置。若该元素在数组中未出现，请返回-1。

测试样例：
[1,2,3,3,4],5,3
返回：2

[元素最左出现](6_binary_search/left_most_appearance.cpp)

## 7_binary_tree
### 递归二叉树的序列
请用递归方式实现二叉树的先序、中序和后序的遍历打印。

给定一个二叉树的根结点root，请依次返回二叉树的先序，中序和后续遍历(二维数组的形式)。

[递归二叉树的序列](7_binary_tree/tree_to_sequece.cpp)

### 非递归二叉树的序列打印
请用非递归方式实现二叉树的先序、中序和后序的遍历打印。

给定一个二叉树的根结点root，请依次返回二叉树的先序，中序和后续遍历(二维数组的形式)。

[非递归二叉树的序列打印](7_binary_tree/tree_to_squence_nore.cpp)

### 二叉树的打印
有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。

给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于500。

[二叉树的打印C++](7_binary_tree/print_tree.cpp)

[二叉树的打印Python](7_binary_tree/print_tree.py)

### 二叉树的序列化
首先我们介绍二叉树先序序列化的方式，假设序列化的结果字符串为str，初始时str等于空字符串。先序遍历二叉树，如果遇到空节点，就在str的末尾加上“#!”，“#”表示这个节点为空，节点值不存在，当然你也可以用其他的特殊字符，“!”表示一个值的结束。如果遇到不为空的节点，假设节点值为3，就在str的末尾加上“3!”。现在请你实现树的先序序列化。

给定树的根结点root，请返回二叉树序列化后的字符串。

[二叉树的序列化](7_binary_tree/tree_string.cpp)

## 8_bit_operation
### 交换
请编写一个算法，不用任何额外变量交换两个整数的值。

给定一个数组num，其中包含两个值，请不用任何额外变量交换这两个值，并将交换后的数组返回。

测试样例：
[1,2]
返回：[2,1]

[交换](8_bit_operation/get_swap.cpp)

### 比较
对于两个32位整数a和b，请设计一个算法返回a和b中较大的。但是不能用任何比较判断。若两数相同，返回任意一个。

给定两个整数a和b，请返回较大的数。

测试样例：
1,2
返回：2

[比较](8_bit_operation/cmp_get_max.cpp)

## 9_permutation_combination
### 方格移动
在XxY的方格中，以左上角格子为起点，右下角格子为终点，每次只能向下走或者向右走，请问一共有多少种不同的走法

给定两个正整数int x,int y，请返回走法数目。保证x＋y小于等于12。

测试样例：
2,2
返回：2

[方格移动](9_permutation_combination/count_ways.cpp)

### 站队问题
n个人站队，他们的编号依次从1到n，要求编号为a的人必须在编号为b的人的左边，但不要求一定相邻，请问共有多少种排法？第二问如果要求a必须在b的左边，并且一定要相邻，请问一共有多少种排法？

给定人数n及两个人的编号a和b，请返回一个两个元素的数组，其中两个元素依次为两个问题的答案。保证人数小于等于10。

测试样例：
7,1,2
返回：[2520,720]

[站队问题](9_permutation_combination/stand_in_line.cpp)

## 10_probability
### 足球比赛
有2k只球队，有k-1个强队，其余都是弱队，随机把它们分成k组比赛，每组两个队，问两强相遇的概率是多大？

给定一个数k，请返回一个数组，其中有两个元素，分别为最终结果的分子和分母，请化成最简分数

测试样例：
4
返回：[3,7]

[足球比赛](10_probability/champion_ship.cpp)

### 蚂蚁
n只蚂蚁从正n边形的n个定点沿着边移动，速度是相同的，问它们碰头的概率是多少？

给定一个正整数n，请返回一个数组，其中两个元素分别为结果的分子和分母，请化为最简分数。

测试样例：
3
返回：[3,4]

[蚂蚁](10_probability/ants_collision.cpp)

## 12_dynamic program
### 找零钱
有数组penny，penny中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim(小于等于1000)代表要找的钱数，求换钱有多少种方法。

给定数组penny及它的大小(小于等于50)，同时给定一个整数aim，请返回有多少种方法可以凑成aim。

测试样例：
[1,2,4],3,3
返回：2

[找零钱](12_dynamic/count_exchange_ways.cpp)

## 13_Brain_teaser
### 涂色I
你要在一个nxm的格子图上涂色，你每次可以选择一个未涂色的格子涂上你开始选定的那种颜色。同时为了美观，我们要求你涂色的格子不能相邻，也就是说，不能有公共边，现在问你，在采取最优策略的情况下，你最多能涂多少个格子？

给定格子图的长n和宽m。请返回最多能涂的格子数目。

测试样例：
1,2
返回：1

[涂色I](13_Brain_teaser/get_most_paint.cpp)

